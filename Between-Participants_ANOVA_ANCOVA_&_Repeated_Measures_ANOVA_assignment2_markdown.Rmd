---
title: "Anova_Assignment2_markdown"
author: '10976294'
date: "12/11/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## <SPAN STYLE="font-family:'Caladea'">Loading the Packages</SPAN>

<SPAN STYLE="font-family:'Caladea'">This is my second R assignment. For this assignment I will work on three separate questions. 
First I will load my packages. The first package I loaded was `tidyverse` which is a collection of R packages that work well together. The second package was `afex` which is used for conducting analysis of factorial experiments (e.g., factorial Analysis of Variance). The third package I loaded was `emmeans` package which is used for running follow-up (post- hoc) tests. Next, I loaded the`visdat` package which provides a visualization of the entire data frame at once while also showing the missing data. I loaded the `ggthemes` package next which contains some extra geoms, scales and themes for ggplot2. Finally, I loaded the `hrbrthemes` package which is a combination of extra ggplot2 themes, scales and utilities.</SPAN>

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(afex) 
library(emmeans) 
library(visdat)
library(ggthemes) 
library (hrbrthemes) 
```

# <SPAN STYLE="font-family:'Caladea'">QUESTION 1</SPAN>

## <SPAN STYLE="font-family:'Caladea'">Reading in the Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I used the function `read_csv` to import my data into R. Comma- separated values (csv) file format is an ideal way to get data into R as each line contains a row of data and the different elements in a line are separated by commas, thereby making it convenient for representing tabular data. 
In R, variables, data, functions etc. are stored in the form of *objects* which can be assigned a name. I saved the data I read into R by creating an object and assigning it to a variable with the name **dataset1**. In order to create the object **dataset1** I used the *assign* operator which is represented as `<-`. </SPAN>

<SPAN STYLE="font-family:'Caladea'">This experiment consisted of a between- participants factor of visual quality with two levels and 96 participants. Participants were either shown a normal word (Normal_Word Condition) or a visually degraded word (Visually_Degraded_Word Condition). Participants’ response time for how quickly they could pronounce a word was measured. 
In the following code chunks Analysis of Variance (ANOVA) will be conducted to determine and interpret the effect of visual quality of word on response time.</SPAN>

```{r, message= FALSE}
dataset1 <- read_csv("assignment_2_dataset_1.csv")

```
## <SPAN STYLE="font-family:'Caladea'">Converting the Data into a Factor</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this step I first visualized my data using the `head()` function which shows the first 6 lines of the dataset. The output showed that the **condition** column is coded as a character, however, the experiment in my dataset consisted of a between- participants factor with two levels (Normal_Word and Visually_Degraded_Word). Hence, I converted the **condition** column to a factor. In order to do so I used the `mutate` function from the `dplyr` package within `tidyverse`. The `mutate` function created a new **condition** column that had been coded as a factor. The following code chunk involved the first use of the pipe operator denoted by `%>%`. The pipe operator is used to pass information along to the line of code after the pipe, thereby, allowing me to chain one function after another. I saved the output in a new object called **factored_dataset1**. Subsequently, I used the `head()` function again to visualize my data which confirmed that the **condition** column had been converted into a factor.</SPAN>

```{r}
head(dataset1)

factored_dataset1 <- dataset1 %>%
  mutate(condition = factor(condition))

head (factored_dataset1)

```
## <SPAN STYLE="font-family:'Caladea'">Recoding the Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I have recoded my data frame in order to make it more representative of the experimental design. The experiment consisted of two conditions- Condition A and Condition B. In Condition A participants were shown a word of normal visual quality, whereas in Condition B participants were shown a visually degraded word.</SPAN>

<SPAN STYLE="font-family:'Caladea'">First, to save my data I created a new object called **recoded**. Next, I used the `mutate` function to change the name of condition_a and condition_b from the condition column and set its values based on the `recode` function. Finally, I used the `colnames` function to change the names of the columns. In the line of code following `colnames`, `recoded` refers to the dataset used, `==` matches the left hand side with the right hand side and `<-` operator assigns the specified value.</SPAN>
```{r}
recoded <- factored_dataset1 %>%
   mutate(condition = recode(condition,
                             "condition_a"= "Normal_Word",
                             "condition_b"= "Visually_Degraded_Word"))
colnames(recoded)[colnames(recoded)== 'participant'] <- 'Participant'
colnames(recoded)[colnames(recoded)== 'condition'] <- 'Condition'
colnames(recoded)[colnames(recoded)== 'response_time'] <- 'Response_Time'

```
## <SPAN STYLE="font-family:'Caladea'">Summary Statistics</SPAN>


<SPAN STYLE="font-family:'Caladea'">In this step I calculated the summary statistics for my data. First, I saved my data in a new object called **statistical_summary**. Next, I used the `group_by` function to group the dataset by the Condition column.
Subsequently, I used the `summarise` function to calculate the summary statistics for both of the experimental conditions (Normal_Word Condition and Visually_Degraded_Word Condition). For both of the experimental conditions I calculated the mean response time, standard deviation of response time, median response time, minimum response time, maximum response time, 25% quantile for response time and the number of observations.  Finally, I used the `arrange` function to order the output by mean response time (highest to lowest). The mean response time for Visually_Degraded_Word Condition was higher (mean= 1020.304 ms) as compared to the Normal_Word Condition (mean= 1002.215 ms).
The functions `group_by` , `summarise` and `arrange` are part of the `dplyr` package within `tidyverse`.</SPAN>

```{r}
statistical_summary <- recoded %>%
  group_by (Condition) %>%
  summarise(mean_Response_Time= mean(Response_Time), 
            sd_Response_Time= sd(Response_Time), 
            median_Response_Time= median(Response_Time),
            min_Response_Time= min(Response_Time),
            max_Response_Time= max(Response_Time),
            quantile_Response_Time= quantile(Response_Time, 0.25),
            number=n()) %>%
arrange(-mean_Response_Time)
```
## <SPAN STYLE="font-family:'Caladea'">Data Visualization</SPAN>

<SPAN STYLE="font-family:'Caladea'">My first visualization demonstrates the effect of visual quality of word on response time. The`ggplot2` package within `tidyverse` was used to make a violin plot including a box plot. The violin plot represents the distribution of the data, while the box plot shows the summary statistics.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have used the **recoded** dataset for this visualization. First, in order to display the sample size on the x axis I have used `left_join` function.  `left_join` function keeps all the columns from the recoded dataset, while also using the common columns in recoded and statistical_summary datasets to add the extra columns (number) in statistical_summary to all the columns of recoded. Next, I have used the `mutate` function to create a new variable myaxis. In the line of code that follows myaxis, the paste function concatenates all the fields inside it to create a string, therefore the value of myaxis column = `(Condition +\n + SampleSize)`. Here, `\n` is the character for a new line. 
 I have used the `geom_violin()` function to produce a violin plot. Next,the `geom_jitter` function has been used to add a small amount of random variation to each point (the alpha value specified after `geom_jitter` indicates the opacity of the geom). 
The `geom_boxplot()` function has been used to create a boxplot for both conditions (Normal_Word and Visually_Degraded_Word). The `stat_summary` function has been used to add some summary data such as the mean and confidence intervals around the mean. In the line of code that follows `stat_summary`, `fun.data`  is a complete summary function and `mean_cl_boot` is used for producing bootstrapped confidence intervals without assuming normality.
 The legend has been suppressed by specifying the `guides` function as none. `theme_igray()` has been used for the plot. The `theme` function has been used to customize the text angle (vjust), size and horizontal adjustment (hjust) on the x and y axes as well as the plot title. Finally, the `labs` function has been used to add the x and y axes labels as well as the title of the plot.  Overall, from the plot it can be seen that the majority of response times for Normal_Word condition were quicker than that for Visually_Degraded_Word condition.</SPAN>



```{r}
recoded%>% 
   left_join(statistical_summary) %>%
  mutate(myaxis = paste0(Condition, "Condition", "\n", "SampleSize=", number)) %>%
  ggplot(aes(x = myaxis, y = Response_Time, colour = Condition)) + 
  geom_violin() +
  geom_jitter(alpha = .2, width = .1) +
  geom_boxplot(alpha = .5, width= .07, color= "black") +
  stat_summary(fun.data = "mean_cl_boot", colour = "black") +
  guides(colour = 'none') + 
  theme_igray()+
  theme(axis.text.x = element_text(angle = 30, hjust = 0.9, size= 9)) +
  theme(axis.title.x = element_text(hjust = 0.4, size= 10)) +
  theme(axis.title.y = element_text(size= 10)) +
  theme(plot.title = element_text(size = 10, hjust= 0.5))+
  labs (title = "Examining the Effect of Visual Quality of Word on Response Time", 
       x = " Visual Quality of Word", 
       y = "Response Time (milliseconds)")    

```


## <SPAN STYLE="font-family:'Caladea'">Building the ANOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have used the `aov_4()` function from within the `afex` package to build the ANOVA model. The line of code following the `aov_4 ()` function represents the syntax used by the `aov_4()` function for ANOVA models i.e.,- `aov_4(DV ~ IV + (1 | Participant), data = recoded)`. The `DV` is `Response_Time` while the `IV` is `Condition`. The `~` symbol corresponds to predicted by, the `(1 | Participant)` term denotes the random effect (random effect refers to selecting a random sample from the population). The last part of the syntax `data= recoded` specifies the dataset I am using. The output of the `aov_4()` function has been saved as a new object called **model**.</SPAN>

```{r}
model <- aov_4(Response_Time ~ Condition + (1 | Participant), data = recoded)

```

## <SPAN STYLE="font-family:'Caladea'">Interpreting the ANOVA Model Output</SPAN>

<SPAN STYLE="font-family:'Caladea'">In order to get the ANOVA output I have used the `summary` function with the previously created `model`. 
[Note that the values listed below have not been rounded off- same has been followed for all values in question 2 and 3 as well].</SPAN>

<SPAN STYLE="font-family:'Caladea'">The ANOVA output revealed a significant effect [F (1,94) = 15.78, p= 0.00013, generalised η2 = 0.14)]. Here, generalised η2 (generalised eta squared) corresponds to the effect size (ges). p < 0.05 shows that the analysis done between the two conditions (Normal_word Condition and Visually_Degraded_Word Condition) is statistically significant. The corresponding ges value of 0.14 bolsters that by denoting that the significance is indeed noticeable to the expert eye. This finding is supported by the plots in the **Data Visualization** section where it can be seen that the visually degraded word took longer for participants to pronounce than the normal word.</SPAN>

<SPAN STYLE="font-family:'Caladea'">Now that it has been determined that there is an effect in the model a further step would be to conduct pairwise comparisons (using the `emmeans ()` function from within the `emmeans` package) in order to determine what is driving the difference. Pairwise comparisons are used when there are multiple population means and help determine which means are different from which means. However, in this case pairwise comparisons would not provide any new information since there are only two conditions in the experiment (the result of the ANOVA is directly representative of these two conditions).</SPAN>
```{r}
summary(model)

print(model)
```


# <SPAN STYLE="font-family:'Caladea'">QUESTION 2</SPAN>

## <SPAN STYLE="font-family:'Caladea'">Reading in the Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I used the function `read_csv` to import my data into R. I saved the data I read into R by creating a new object called **dataset2**. </SPAN>

<SPAN STYLE="font-family:'Caladea'">This experiment used the same dataset as the first question with the addition of a new measure i.e., caffeine consumption (per cup). The experiment was the same as question one where participants were either shown a normal word (Normal_Word Condition) or a visually degraded word (Visually_Degraded_Word Condition). Participants’ response time for how quickly they could pronounce a word was measured.  However, in order to account for the addition of caffeine consumption both ANOVA and Analysis of Covariance (ANCOVA) will be conducted to determine and interpret the effect of visual quality of word on response time (when taking account of caffeine consumption). Additionally, the equivalent linear model will be built and compared with the ANOVA output.</SPAN>


```{r, message=FALSE}
dataset2 <- read_csv ("assignment_2_dataset_2.csv")
```
## <SPAN STYLE="font-family:'Caladea'">Converting the Data into a Factor</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this step I first visualized my data using the `head()` function. The output showed that the **condition** column is coded as a character, however, the experiment in my dataset consisted of condition as a factor. Hence, I converted the **condition** column to a factor. In order to do so I used the `mutate` function. The `mutate` function created a new **condition** column that had been coded as a factor. I saved the output in a new object called **factored_dataset2**. Subsequently, I used the `head()` function again to visualize my data which confirmed that the **condition** column had been converted into a factor.</SPAN>

```{r}
head(dataset2)

factored_dataset2 <- dataset2 %>%
  mutate(condition = factor(condition))

head(factored_dataset2)

```
## <SPAN STYLE="font-family:'Caladea'">Recoding the Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I have recoded my data frame in order to make it more representative of the experimental design. The experiment consisted of two conditions- Condition A and Condition B. In Condition A participants were shown a word of normal visual quality, whereas in Condition B participants were shown a visually degraded word. Additionally, there was also a measure of caffeine consumption for each participant.</SPAN>

<SPAN STYLE="font-family:'Caladea'">First, to save my data I created a new object called **recoded2**. Next, I used the `mutate` function to change the name of condition_a and condition_b from the condition column and set its values based on the `recode` function. Finally, I used the `colnames` function to change the names of the columns. In the line of code following `colnames`, `recoded2` refers to the dataset used, `==` matches the left hand side with the right hand side and `<-` operator assigns the specified value.</SPAN>

```{r}
recoded2 <- factored_dataset2 %>%
   mutate(condition = recode(condition,
                             "condition_a"= "Normal_Word",
                             "condition_b"= "Visually_Degraded_Word"))
colnames(recoded2)[colnames(recoded2)== 'participant'] <- 'Participant'
colnames(recoded2)[colnames(recoded2)== 'condition'] <- 'Condition'
colnames(recoded2)[colnames(recoded2)== 'response_time'] <- 'Response_Time'
colnames(recoded2)[colnames(recoded2)== 'caffeine'] <- 'Caffeine_Intake'
```
## <SPAN STYLE="font-family:'Caladea'">Statistical Summary</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this step I calculated the summary statistics for my data. First, I saved my data in a new object called **statistical_summary2**. Next, I used the `group_by` function to group the dataset by the Condition column.</SPAN>

<SPAN STYLE="font-family:'Caladea'">Subsequently, I used the `summarise` function to calculate the summary statistics for both of the experimental conditions (Normal_Word Condition and Visually_Degraded_Word Condition). For both of the experimental conditions I calculated the mean response time, standard deviation of response time, median response time, minimum response time, maximum response time, 25% quantile for response time and the number of observations.  Finally, I used the `arrange` function to order the output by mean response time (highest to lowest). 
The mean response time for Visually_Degraded_Word Condition was higher (mean= 1020.304 ms) relative to the Normal_Word Condition (mean= 1002.215 ms).</SPAN>


```{r}
statistical_summary2 <- recoded2 %>%
  group_by (Condition) %>%
  summarise(mean_Response_Time= mean(Response_Time), 
            sd_Response_Time= sd(Response_Time), 
            median_Response_Time= median(Response_Time),
            min_Response_Time= min(Response_Time),
            max_Response_Time= max(Response_Time),
            quantile_Response_Time= quantile(Response_Time, 0.25),
            number=n()) %>%
arrange(-mean_Response_Time)
```
## <SPAN STYLE="font-family:'Caladea'">Data Visualization</SPAN>

<SPAN STYLE="font-family:'Caladea'">This visualization demonstrates the distribution of caffeine intake between both conditions (Normal_Word and Visually_Degraded_Word).  I used the `geom_point` function (from`ggplot2` package within `tidyverse` ) to make a scatterplot in order to determine the relationship between caffeine intake and response time. In the line of code following `geom_point`, size indicates the size of the points in the plot, while alpha denotes the transparency of the points.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have used the **recoded2** dataset for this visualization. The `labs` function has been used to add the x and y axes labels as well as the title of the plot. `theme_stata()` has been used for the plot. The `theme` function has been used to customize the text angle (vjust), size and horizontal adjustment (hjust) on the legend, x and y axes as well as the plot title. Overall, from the plot it can be seen that people who were shown the visually degraded word were given more cups of coffee (between 3-6 cups of coffee) as compared to people who were shown the normal word (they were given between 0-3 cups of coffee).</SPAN>

```{r}
ggplot(recoded2, aes(x = Caffeine_Intake, y = Response_Time,  colour = Condition)) + 
  geom_point(size = 3, alpha = 0.9) +
  labs(title= "Distribution of Caffeine Intake Between Both Conditions",
       x = "Caffeine Intake (per cup)", 
       y = "Response Time (milliseconds)") +
  theme_stata()+
  theme(plot.title = element_text(size = 10, hjust= 0.5)) +
   theme(axis.text.x = element_text(hjust = 0.9, size= 9)) +
  theme(axis.title.x = element_text(hjust = 0.5, size= 10)) +
  theme(axis.title.y = element_text(hjust = 0.5, size= 10)) +
  theme(legend.title = element_text(size= 9))+
  theme(legend.text = element_text(vjust= 0.6, size= 9)) +
  theme(legend.position = "bottom") +
  theme(text = element_text(size = 10)) 
  
        
```

## <SPAN STYLE="font-family:'Caladea'">Building the ANOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">Similar to the **Building the ANOVA Model** section in question 1, I have used the `aov_4()`  function to build the ANOVA model. I will build the ANOVA model first without taking into account the presence of the covariate **Caffeine_Intake** (the covariate will be addressed later).
Here, the syntax for building the ANOVA model is similar to what was done in question 1 **Building the ANOVA Model** section apart from two differences - the dataset being used is recoded2 and the output of the `aov_4()` function has been saved as a new object called **anova_ model**.</SPAN>
```{r,}
anova_model <-aov_4(Response_Time ~ Condition + (1 | Participant), data = recoded2)

```
## <SPAN STYLE="font-family:'Caladea'">Interpreting the ANOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here, I have generated the ANOVA table using the `anova` function and the previously created anova_model. The result is the same as what was obtained in question 1 **Interpreting the ANOVA Model Output** section with the ANOVA output revealing a significant effect [F (1,94) = 15.78, p= 0.00013, generalised η2 = 0.14)] of Condition.</SPAN>
```{r}
anova(anova_model)

```

## <SPAN STYLE="font-family:'Caladea'">Pairwise Comparisons</SPAN>

<SPAN STYLE="font-family:'Caladea'">In the first question I did not conduct pairwise comparisons as there are only two conditions and conducting follow-up tests would not provide any new information. However, in this case I will conduct pairwise comparisons as I want to use the emmean for the Normal_Word Condition and Visually_Degraded_Word Condition for subsequent analysis.</SPAN>

<SPAN STYLE="font-family:'Caladea'">Therefore, the `emmeans()` function has been used to conduct pairwise comparisons. The line of code that follows `emmeans()` first denotes the dataset to be used and then indicates that pairwise is predicted by (`~`) Condition. It is important to note here that since I have not specified an adjustment for multiple comparisons (e.g., Bonferroni correction) the default adjustment for multiple comparisons in R will be used i.e., **Tukey's**.  
Tukey comparisons reveal that response time for participants in the Normal_Word condition (1002 ms) was significantly quicker than that for participants in the Visually_Degraded_Word condition (1020 ms) (p< 0.001). This means that participants took longer to respond to a visually degraded word as compared to a normal word. However, while I can see here that the two conditions differ significantly from each other I cannot draw a final conclusion without taking into account the effect of the covariate. The covariate has been accounted for in the next chunk of code.</SPAN>
```{r}
emmeans(anova_model, pairwise ~ Condition)

```

## <SPAN STYLE="font-family:'Caladea'">ANCOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I will build an ANCOVA model by adding the covariate **Caffeine_Intake** before the experimental Condition manipulation. The factorize parameter has been set to FALSE so that the covariate is seen as a continuous predictor (a variable that can take on any value within a range) rather than an experimental factor in the model. The output has been stored in a new object called **model_ancova**.</SPAN>
```{r, message=FALSE, warning=FALSE}
model_ancova <- aov_4(Response_Time ~ Caffeine_Intake + Condition + (1 | Participant), data = recoded2, factorize = FALSE)

```
## <SPAN STYLE="font-family:'Caladea'">Interpreting the ANCOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here, I have built the ANOVA table using the `anova` function and the previously created **model_ancova**.</SPAN>

<SPAN STYLE="font-family:'Caladea'">The results of this output reveal that there is a very small effect of Condition (ges= 0.036) and the covariate (Caffeine_Intake) (ges = 0.011). However, the effect is not significant for both Condition (p =0.061) and Caffeine_Intake (p =0.292). This means that after controlling for the covariate (Caffeine_Intake) the  Independent Variable (Condition) is no longer significant (note that a significant effect of Condition was found in **Interpreting the ANOVA Model** section, when not accounting for Caffeine_Intake). Therefore, while the covariate itself does not have a significant effect it was still accounting for the significant effect of Condition found earlier.</SPAN>


```{r}
anova(model_ancova)

```
## <SPAN STYLE="font-family:'Caladea'">Pairwise Comparisons for ANCOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here, again I have used the `emmeans()` function to produce the adjusted means (i.e., the means for both the conditions taking into account the influence of the covariate). The emmeans will subsequently be used to validate ANCOVA as a linear model in the next few code chunks. 
The Tukey comparisons reveal no significant difference between the two conditions i.e., Normal_Word Condition (1005 ms) and Visually_Degraded_Word (1018 ms) (when covariate is accounted for) (p= 0.06).</SPAN> 

```{r}
emmeans(model_ancova, pairwise ~ Condition)

```
## <SPAN STYLE="font-family:'Caladea'">ANOVA and ANCOVA as a Special Case of Regression</SPAN>

<SPAN STYLE="font-family:'Caladea'">I will now look at ANOVA and ANCOVA as a special case of regression. First, I will visualize my data.</SPAN>

<SPAN STYLE="font-family:'Caladea'">This plot is similar to the visualization made in the **Data Visualization** section of question 1 and follows the same code with some minor adjustments to the theme.</SPAN>

<SPAN STYLE="font-family:'Caladea'">This plot demonstrates the effect of visual quality of word on response time.  I have used the`ggplot2` package within `tidyverse` to make a violin plot including a box plot. The violin plot represents the distribution of the data, while the box plot shows the summary statistics.</SPAN>

<SPAN STYLE="font-family:'Caladea'"> For this visualization, I have used the **recoded2** dataset. First, in order to display the sample size on the x axis I have used the `left_join` function.  `left_join` function keeps all the columns from the recoded2 dataset, while also using the common columns in recoded2 and statistical_summary2 datasets to add the extra columns (number) in statistical_summary2 to all the columns of recoded2. Next, I have used the `mutate` function to create a new variable myaxis. In the line of code that follows myaxis, the paste function concatenates all the fields inside it to create a string, therefore the value of myaxis column = `(Condition +\n + SampleSize)`. Here, `\n` is the character for a new line. 
 The `geom_violin()` function has been used to produce a violin plot. Subsequently, I have used the `geom_jitter` function to add a small amount of random variation to each point (the alpha value specified after `geom_jitter` refers to the opacity of the geom). 
The `geom_boxplot()` function has been used to create a boxplot for both conditions (Normal_Word and Visually_Degraded_Word). The `stat_summary` function has been used to add some summary data such as the mean and confidence intervals around the mean. In the line of code that follows `stat_summary` , `fun.data`  is a complete summary function,and `mean_cl_boot` is used for producing bootstrapped confidence intervals without assuming normality.
 The legend has been suppressed by specifying the `guides` function as none. `theme_solarized()` has been used for the plot. The `theme` function has been used to customize the text angle (vjust), size and horizontal adjustment (hjust) on the x and y axes as well as the plot title. Finally, the `labs` function has been used to add the x and y axes labels as well as the title of the plot.  The plot shows that the majority of response times for Normal_Word Condition were quicker than that for Visually_Degraded_Word Condition.</SPAN>




```{r}
  recoded2 %>%
   left_join(statistical_summary2) %>%
  mutate(myaxis = paste0(Condition, "Condition", "\n", "SampleSize=", number)) %>%
  ggplot(aes(x = myaxis, y = Response_Time, colour = Condition)) + 
  geom_violin() +
  geom_jitter(alpha = .2, width = .1) +
  geom_boxplot(alpha = .5, width= .07, color="black") +
  guides(colour = 'none') + 
    stat_summary(fun.data = mean_cl_boot, colour = "black") +
  theme_solarized()+
   theme(axis.text.x = element_text(angle = 30, hjust = 0.9, size= 9, color= "black")) +
  theme(axis.title.x = element_text(hjust = 0.4, size= 10, color= "black")) +
  theme(axis.title.y = element_text(size= 10, color= "black")) +
  theme(plot.title = element_text(size = 9, hjust= 0.5, color="black"))+
  labs (title = "Examining the Effect of Visual Quality of Word on Response Time", 
       x = " Condition", 
       y = "Response Time (milliseconds)")
```

## <SPAN STYLE="font-family:'Caladea'">Setting up the Contrasts</SPAN>


<SPAN STYLE="font-family:'Caladea'">First, I will check how the Condition factor is currently coded in terms of its contrasts. Here, the expression `recoded2$Condition` is the Base R way of referring to the variable called Condition in the dataset recoded2.</SPAN>

```{r}
contrasts(recoded2$Condition)

```
## <SPAN STYLE="font-family:'Caladea'">Using the `fct_relevel` Function</SPAN>

<SPAN STYLE="font-family:'Caladea'">I want the Normal_Word condition to be the reference level, thereby corresponding to the intercept of the linear model. In order to do so the `fct_relevel` function (from the `forcats` package within `tidyverse`) has been used.</SPAN>

<SPAN STYLE="font-family:'Caladea'">`fct_relevel` function allows me to move any number of levels to any location. It is important to note here that even though the default ordering by alphabetical order places Normal_Word before Visually_Degraded_Word, I am using `fct_relevel` to be explicit that I want Normal_Word to precede Visually_Degraded_Word. Additionally, the default contrast values signify that the mean of Normal_Word is being used as the basis of calculations in the linear model.</SPAN>
```{r}
releveled <- recoded2 %>%
  mutate(Condition = fct_relevel(Condition,
                                 c("Normal_Word", "Visually_Degraded_Word")))

contrasts(releveled$Condition)
```
## <SPAN STYLE="font-family:'Caladea'">ANOVA as a Linear Model</SPAN>


<SPAN STYLE="font-family:'Caladea'">In this code chunk I will model the linear model using the `lm` function. The line of code that follows `lm` denotes that Response_Time is predicted by (`~`) Condition and the releveled dataset has been used. It can be seen that the Intercept corresponds to the mean of Normal_Word (refer to **Pairwise Comparisons** section). To work out the mean response time of the Normal_Word Condition and the Visually_Degraded_Word Condition the following equations have been used (contrast= 0,1):</SPAN>
<SPAN STYLE="font-family:'Caladea'">Response_ Time = intercept + </br> β1(Visually_Degraded_Word)</SPAN>

<SPAN STYLE="font-family:'Caladea'">Mean for Normal_Word Condition :</br>
Response_Time = 1002.22 + 18.09(0)</br>
Response_Time = 1002.22</SPAN>

<SPAN STYLE="font-family:'Caladea'">Mean for Visually_Degraded_Word Condition:</br>
Response_Time = 1002.22 + 18.09(1)</br>
Response_Time = 1020.31</SPAN>


```{r}
model_lm <- lm(Response_Time ~ Condition, data = releveled)
model_lm
```
## <SPAN STYLE="font-family:'Caladea'">ANCOVA as a Linear Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here, I will build the ANCOVA model using the `lm` function. In order to do so I will add the covariate (Caffeine_Intake) to the model specification.</SPAN>

```{r}
model_ancova <- lm(Response_Time ~ Caffeine_Intake + Condition, data = releveled)
model_ancova

```
## <SPAN STYLE="font-family:'Caladea'">Adjusted Means</SPAN>
 
<SPAN STYLE="font-family:'Caladea'">I can calculate the mean of my reference condition (Normal_Word) by plugging in the values from the above table to the liner model equations. However, since Caffeine_Intake is not a factor I have to enter its mean.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have calculated the mean of Caffeine_Intake below by using the `mean` function, the `$` operator is used to extract a specific part of a data object.The mean was found to be 2.552083. To work out the mean response time of Normal_Word Condition and Visually_Degraded_Word Condition the following equations have been used (contrast= 0,1):</SPAN>


<SPAN STYLE="font-family:'Caladea'">Response_Time = intercept + β1(Caffeine_Intake mean) + β2(Visually_Degraded_Word mean). Here β1=2.469 and β2 = 0 (for Normal_Word); β2= 1 (for Visually_Degraded_Word) </br>
Mean for Normal_Word Condition:</br>
Response_Time = 998.5 + 2.469(2.552) + 18.09(0)</br>
Response_Time = 998.5 + 6.3</br>
Response_Time = 1004.8</SPAN>

<SPAN STYLE="font-family:'Caladea'"><br>Mean for Visually_Degraded_Word Condition:</br>
Response_Time = 998.5 + 2.469(2.552) + 12.79(1)</br>
Response_Time = 998.5 + 6.3 + 12.79</br>
Response_Time = 1017.59</SPAN><br>


<SPAN STYLE="font-family:'Caladea'">1004.8 (≈ 1005) is the adjusted mean for the Normal_Word condition which corresponds to what was found from the pairwise comparisons for the ANCOVA model (**Pairwise Comparisons for ANCOVA Model** section).</SPAN>
```{r}
mean(releveled$Caffeine_Intake)

```
## <SPAN STYLE="font-family:'Caladea'">Centering the Covariate</SPAN>

<SPAN STYLE="font-family:'Caladea'">In the next few code chunks I will demonstrate how the covariate can be scaled and centered. This standardizes the variable (with the mean centered on zero) while also removing the need to multiply the linear model coefficient for the covariate by the covariate’s mean. This makes interpreting the coefficients in the linear model easier.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have used the `scale()` function to create a new (scaled and centered) version of the covariate.</SPAN>
```{r}
my_scaled_data <- releveled%>%
  mutate(centred_Caffeine_Intake = scale(Caffeine_Intake))
```


## <SPAN STYLE="font-family:'Caladea'">Visualizing Both the Centered and Uncentered Covariate</SPAN>


<SPAN STYLE="font-family:'Caladea'"> Here, I can look at both the uncentered and the centered covariate to see that nothing has changed in the data, other than the variable mean is now centered on zero and the distribution has been scaled.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have plotted (density plot) both the uncentered and centered covariate. The only difference between the two plots is that in the second plot the variable mean is centered on zero and the distribution has also been scaled.</SPAN>
```{r}
plot(density(my_scaled_data$Caffeine_Intake))

plot(density(my_scaled_data$centred_Caffeine_Intake))

```


## <SPAN STYLE="font-family:'Caladea'">Linear Model with Scaled and Centered Covariate</SPAN>

<SPAN STYLE="font-family:'Caladea'">I will now build a linear model with the scaled and centered covariate. 
Centering the plot on the covariate changes the linear model equations by removing the coefficient for caffeine. This allows for easier analysis of the plot by making the linear model equations depend on just the intercept and Visually_Degraded_Word. Therefore, it can be seen that the Intercept corresponds to the adjusted mean for the Normal_Word Condition (mean= 1004.864) (refer to the equations in the **Adjusted Means** section for comparison, minus the covariate variable). Additionally, mean of Visually_Degraded_Word Condition can be calculated as: Intercept (1004.864) + 12.791= 1017.655. Here β2= 12.791</SPAN>

```{r}
model_ancova_centred <- lm(Response_Time ~ centred_Caffeine_Intake + Condition, data = my_scaled_data)
model_ancova_centred
```


# <SPAN STYLE="font-family:'Caladea'">QUESTION 3</SPAN>

## <SPAN STYLE="font-family:'Caladea'">Reading in the Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I used the function `read_csv` to import my data into R. I have saved the data by creating a new object with the name **dataset3**.</SPAN>

<SPAN STYLE="font-family:'Caladea'">This experiment involved a 2×2 repeated measures design with 148 participants. Participants were asked to respond to a target image with either positive or negative valence. The target was preceded by a prime which was also either positive or negative in valence. 
In the following code chunks Factorial ANOVA will be conducted to determine whether people respond faster to positive images preceded by a positive prime and faster to negative images preceded by a negative prime.</SPAN>

```{r,message=FALSE}
dataset3 <- read_csv("assignment_2_dataset_3.csv")
```

## <SPAN STYLE="font-family:'Caladea'">Reshaping the Data into Long Format</SPAN>

<SPAN STYLE="font-family:'Caladea'">The above data was for a 2×2 repeated measures experiment with 148 participants. This data was in a wide format (i.e., multiple observations per row) and needed to be converted into the long format (a column for every dimension and a row for every observation). This step was important since reshaping the data file into the long format transformed the data set into a tidier format, thereby making it more appropriate for producing data visualizations, running descriptive statistics and conducting the ANOVA. I created a new object called **longer_data3** in order to save the output. Subsequently, I specified the data frame I wanted to reshape i.e., **dataset3**. 
Next, I used the `pivot_longer` function (from the `tidyr` package within `tidyverse`) to reshape the data into long format. The code following `pivot_longer` specifies the columns that I want to pivot into the long format, the name of the new column that will be created and the name of the column that will contain the values of the reshaped data.</SPAN>


```{r}
longer_data3 <- dataset3 %>%
  pivot_longer(cols = c(positiveprime_positivetarget, positiveprime_negativetarget, negativeprime_positivetarget, negativeprime_negativetarget), 
               names_to = "Condition", 
               values_to = "Response_Time")
```
## <SPAN STYLE="font-family:'Caladea'">Converting the Data into a Factor</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk, I first visualized my data using the `head()` function. The output showed that the **Condition** column is coded as a character, however, the experiment in my dataset consisted of condition as a factor. Hence, I converted the **Condition** column to a factor. In order to do so I used the `mutate` function. The `mutate` function created a new **Condition** column that had been coded as a factor. I saved the output in a new object called **factored_longer_data3**. Subsequently, I used the `head()` function again to visualize my data which confirmed that the **Condition** column had been converted into a factor.</SPAN>

```{r}
head (longer_data3)

factored_longer_data3 <- longer_data3 %>%
  mutate(Condition = factor(Condition))

head(factored_longer_data3)
```
## <SPAN STYLE="font-family:'Caladea'">Recoding the Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">In this code chunk I have recoded my data frame in order to make it more representative of the experimental design. The experiment consisted of two factors- Prime and Target with each having two levels- positive and negative valence.</SPAN>

<SPAN STYLE="font-family:'Caladea'">First, to save my data I created a new object called **recoded3 **. Next, I used the `mutate` function to make two new columns **Prime** and **Target** from the condition column.  In the line of code following `mutate` the `case_when` (part of `dplyr` package within `tidyverse`) function has been used as it allows me to vectorize various if and when statements. Next, `grepl` function (part of Regular Expressions in Base R) has been used to match a particular string to a particular value in a column. For example, when the condition column contains the string PositivePrime_PositiveTarget the corresponding entry in column Prime will be Positive and the corresponding entry in column Target will also be Positive. `colnames` function has been used to give a new name to the column (this was primarily done to capitalize the first alphabet of the word participant)</SPAN>


```{r}
 recoded3 <- factored_longer_data3 %>%
  mutate(Prime = case_when(
    grepl("positiveprime_positivetarget", Condition) ~ "Positive",
    grepl("positiveprime_negativetarget", Condition) ~ "Positive",
    grepl("negativeprime_positivetarget", Condition) ~ "Negative",
    grepl("negativeprime_negativetarget", Condition) ~ "Negative",
    )) %>% mutate(Target = case_when(
    grepl("positiveprime_positivetarget", Condition) ~ "Positive",
    grepl("positiveprime_negativetarget", Condition) ~ "Negative",
    grepl("negativeprime_positivetarget", Condition) ~ "Positive",
    grepl("negativeprime_negativetarget", Condition) ~ "Negative",
    ))
colnames(recoded3)[colnames(recoded3)== 'participant'] <- 'Participant'

```
## <SPAN STYLE="font-family:'Caladea'">Using the `subset` Function</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here, I have used the `subset` (part of Base R and useful for selecting elements of a dataset) function to delete the condition column as it is no longer needed in the new recoded3 dataset (this dataset contains the new columns Prime and Target). The output has been saved as a new object called **tidied_data**.</SPAN>

```{r}
tidied_data <- subset( recoded3, select = -Condition )
```
## <SPAN STYLE="font-family:'Caladea'">Converting the Data into a Factor</SPAN>

<SPAN STYLE="font-family:'Caladea'"> In this step I first visualized my data using the `head()` function. The output showed that the **Prime** and **Target** columns are coded as characters, however, the experiment in my dataset consists of Prime and Target as factors. Hence, I converted the **Prime** and **Target** columns to a factor. In order to do so I used the `mutate` function. The `mutate` function created a new **Condition** column that had been coded as a factor. I saved the output in a new object called **factored_tidied_data**. Subsequently, I used the `head()` function again to visualize my data which confirmed that the **Prime** and **Target** columns had been converted into factors.</SPAN>
```{r}
head (tidied_data)

factored_tidied_data <- tidied_data %>%
  mutate(Prime = factor(Prime), Target = factor(Target))

head (factored_tidied_data)
```
## <SPAN STYLE="font-family:'Caladea'">Statistical Summary</SPAN>


<SPAN STYLE="font-family:'Caladea'">In this step I calculated the summary statistics for my data. First, I saved my data in a new object called **statistical_summary3**. Next, I used the `group_by` function to group the dataset by the **Prime** and **Target** columns. 
Subsequently, I used the `summarise` function to calculate the summary statistics for each level of Prime and Target (positive and negative valence). Next, I calculated the mean response time, standard deviation of response time, median response time, minimum response time, maximum response time, 25% quantile for response time and the number of observations.  Finally, I used the `arrange` function to order the output by mean response time (highest to lowest). The mean response time for PositivePrime_NegativeTarget (mean= 1566.984 ms) was highest while the mean response time for NegativePrime_NegativeTarget (mean= 1547.254 ms) was lowest.</SPAN>

```{r, message=FALSE}
statistical_summary3 <- factored_tidied_data %>%
  group_by (Prime, Target) %>%
  summarise(mean_Response_Time= mean(Response_Time), 
            sd_Response_Time= sd(Response_Time), 
            median_Response_Time= median(Response_Time),
            min_Response_Time= min(Response_Time),
            max_Response_Time= max(Response_Time),
            quantile_Response_Time= quantile(Response_Time, 0.25),
            number=n()) %>%
arrange(-mean_Response_Time)
```

## <SPAN STYLE="font-family:'Caladea'">Visualising the Missing Data</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here I used the `vis_miss` function (from `visdat` package) to check whether there is any missing data. The output confirmed that there is no missing data.</SPAN>

```{r}
vis_miss(factored_tidied_data)

```


## <SPAN STYLE="font-family:'Caladea'">Data Visualization</SPAN>

<SPAN STYLE="font-family:'Caladea'">This plot represents the effect of bi-valence prime and target on response time to target image. I made use of the`ggplot2` package (from within `tidyverse`) to make a violin plot including a box plot. The violin plot shows the distribution of the data, while the box plot represents the summary statistics.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I have used the **factored_tidied_data** dataset for this visualization. First, in order to display the sample size on the x axis I have used `left_join` function.  `left_join` function keeps all the columns from the factored_tidied_data dataset, while also using the common columns in factored_tidied_data and statistical_summary3 datasets to add the extra columns (number) in statistical_summary3 to all the columns of factored_tidied_data. Next, I have used the `mutate` function to create a new variable myaxis. In the line of code that follows myaxis, the paste function concatenates all the fields inside it to create a string, therefore the value of myaxis column = `(Condition +\n + SampleSize)`. Here, `\n` is the character for a new line. 
 A violin plot has been produced by using the `geom_violin()` function. Next,the `geom_jitter` function has been used to add a small amount of random variation to each point (the alpha value specified after `geom_jitter` refers to the opacity of the geom). 
The `geom_boxplot()` function has been used to create a boxplot for each level of the two factors (Prime and Target) which visualizes the response time. The `stat_summary` function has been used to add some summary data such as the mean and confidence intervals around the mean. In the line of code that follows `stat_summary`, `fun.data` is a complete summary function, `mean_cl_boot` is used for producing bootstrapped confidence intervals without assuming normality.
The legend has been suppressed by specifying the `guides` function as none. `theme_ipsum()` has been used for the plot. The `theme` function has been used to customize the text angle (vjust), size and horizontal adjustment (hjust) on the x and y axes as well as the plot title. Finally, the `labs` function has been used to add the x and y axes labels as well as the title of the plot.  From the plot it can be seen that response times for NegativePrime:NegativeTarget as well as PositivePrime:NegativeTarget were almost uniformly spread between minimum response time (1416.715 ms and 1448.266 ms) and maximum response time (1710.030 ms and 1693.832 ms).
Response times for NegativePrime:PositiveTarget were centered around the mean with low variance. Conversely, the response times for PositivePrime:PositiveTarget showed the most variance.</SPAN>





```{r, warning=FALSE}
factored_tidied_data%>% 
  left_join(statistical_summary3) %>%
  mutate(myaxis = paste0(Prime, "Prime:", Target, "Target", "\n", "SampleSize=", number)) %>%
  ggplot(aes(x = myaxis, y = Response_Time, colour = Prime:Target)) + 
  geom_violin() +
  geom_jitter(alpha = .2, width = .1) +
  geom_boxplot(alpha = .5, width= .07, color= "black") +
  guides(colour = 'none') + 
  stat_summary(fun.data = "mean_cl_boot", colour = "black") +
  theme_ipsum()+
  theme(axis.text.x = element_text(angle = 30, hjust = 0.9, size= 8)) +
  theme(axis.title.x = element_text(hjust = 0.4, size= 10)) +
  theme(axis.title.y = element_text(size= 10)) +
  theme(plot.title = element_text(size = 9, hjust= 0.5))+
  labs (title = "Examining the Effect of Bi Valence Prime and Target on Response Time to Target Image ", 
       x = " Prime and Target", 
       y = "Response Time (milliseconds)" )
```


## <SPAN STYLE="font-family:'Caladea'">Building the Anova Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">Here, I have used the `aov_4()` function to conduct the factorial ANOVA. The syntax is similar to when `aov_4()` was used previously in question 1 and question 2. However, in this line of a code a new term has been added Prime * Target. This term corresponds to two main effects, as well as the interaction between them. Finally, the dataset to be used has been specified i.e., factored_tidied_data. The output has been stored in a new object called model_participant.</SPAN>
```{r}
model_participant <- aov_4(Response_Time ~ Prime * Target + (1 + Prime * Target | Participant), data = factored_tidied_data)
```
## <SPAN STYLE="font-family:'Caladea'">Interpreting the ANOVA Model</SPAN>

<SPAN STYLE="font-family:'Caladea'">The `anova` function has been used to generate the output.</SPAN>

<SPAN STYLE="font-family:'Caladea'">I conducted a 2 (Prime: Positive vs. Negative) x 2 (Target: Positive vs. Negative) repeated measures ANOVA to examine the effect of bi valence Prime and Target on response time to target image.</SPAN>

<SPAN STYLE="font-family:'Caladea'">The ANOVA revealed no effect of Prime [F(1,147)= 0.315, p= 0.575, ηG2= 0.00049], no effect of Target [F(1, 147) = 0.237, p = 0.626, ηG2 = .000431), but an interaction between Prime and Target was found [F(1, 147) = 17.254, p = 5.523e-05, ηG2 = .0292] albeit with a small effect (ges= 0.0292).</SPAN>

```{r}
anova(model_participant)

```

## <SPAN STYLE="font-family:'Caladea'">Pairwise Comparisons</SPAN>

<SPAN STYLE="font-family:'Caladea'">Now, I will conduct pairwise comparisons using the `emmeans()` function. The line of code that follows `emmeans()` first specifies the dataset to be used and next it denotes that pairwise is predicted by Prime * Target. Finally, the error correction adjustment used is `bonferroni`.</SPAN>



<SPAN STYLE="font-family:'Caladea'">The interaction was interpreted by conducting Bonferroni-corrected pairwise comparisons. These comparisons revealed that a negative target was processed quicker when preceded by a negative prime vs. positive prime (1547 ms vs 1567 ms, p= 0.012). I can also see a similar result for positive target where the response time was quicker when preceded by a positive prime vs a negative prime (1547 ms vs. 1563 ms, p= 0.0252).</SPAN> 

```{r}
emmeans(model_participant, pairwise ~ Prime * Target, adjust = "bonferroni")

```

